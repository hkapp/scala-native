- codebase compilation
- same arg reduce
- canonicalize
- inst combine
~ test various passes placement
- tests for the optimization passes
- dominator tree unit tests
- removing the parameters for a block reached by a try is a problem ?

- InstCombine patterns:
 > a = xor true, b; if a then c else d => if b then d else c (still need to keep the xor, cleaned up by DCE)
 > same with select
 > %src.24 = imul[i32] %src.23: i32, 2i32
 > %tx.65 = select %tx.2496: bool, true, false
 > select with same two operands

- look at Swift and LLVM cf simplification

Swift:
- propagate/remove basic block input values when all predecessors supply the same argument, or the parameter itself
- constant fold switch
- change switch with one case to if ?
- condition forwarding
- if a then b else c => in b, we know a is true (if only parent), same for c and for switches
- could try to simplify jump a(true) , a(b): ..... if b then ..

LLVM:
- bb-vectorize : has instruction combine in it
- jump-threading
- sccp
- simplifycfg
  -> eliminate arg for basic block that have a single predecessor (subsumed by propagating same args)
  -> remove if a then b else c ; b: if a then d else e => if a then d else c